---
title: "Single-cell RNA-seq analysis: Clustering"
author: "Csilla Varnai"
date: "2022-09-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(Seurat)
library(patchwork)
```


You will continue to be analysing a scRNA-seq dataset of peripheral blood cells,
generated by the 10X Genomics technology, using the Seurat R package().

This activity follows the PBMC tutorial using Seurat, as can be found here:
https://satijalab.org/seurat/articles/pbmc3k_tutorial.html

First, let us input the filtered scRNA-seq data we have previously created, using the readRDS() function.


```{r}
pbmc_filtered <- readRDS("pbmc3k_filtered.rds")
pbmc_filtered
```


# 1. Normalising the data

Before we can proceed with the analysis of our dataset, we need to normalise the data.  This ensures that expression levels of cells can be directly compared to one another.
Run the NormalizeData() function, which scales the total expression levels to the same value and then aapplies a log transform of the counts, to reduce the skewness of the count distribution.

#Normalized values are stored in pbmc[["RNA"]]@data.

```{r}
pbmc_filtered <- NormalizeData(pbmc_filtered, normalization.method = "LogNormalize", scale.factor = 10000)
```


## Identification of highly variable features (feature selection)

Next, we will look for highly variable genes, which tend to capture the biological variability between cell types.
These are genes that are highly expressed in some cells, and lowly expressed in other cells,
compared to their mean expression level across all cells, similar to what we do in bulk RNA-seq data analysis.

Run the FindVariableFeatures() function, and find the 2,000 most variable genes.
Using this selection of genes will save computing time in further analysis,
compared to using the total 13,714 genes, most of which show little variability in expression levels.

```{r}
pbmc_filtered <- FindVariableFeatures(pbmc_filtered, selection.method = "vst", nfeatures = 2000)
```

The top variable genes can be printed using the head() function.

```{r}
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc_filtered), 10)
top10
```

We can also plot the variance in expression as a function of the mean.
Look at the help of the LabelPoints() function, how to print the top 10 most highly variably expressed genes in the plot.

```{r}
# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc_filtered)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2
```

## Scaling the data

Before analysing the dataset, we will apply a linear transform of the data so that each cell has a comparable distribution of expression for the future analysis steps.
We use the ScaleData() function, which can also regress out covariate variables if specified.

```{r}
all.genes <- rownames(pbmc_filtered)
pbmc_filtered <- ScaleData(pbmc_filtered, features = all.genes)
```

The standardised expression data is stored in pbmc_filtered[["RNA"]]@scale.data

```{r}
pbmc_filtered[["RNA"]]@scale.data[1:2,1:3]
```


# 2. Dimensionality reduction

As most genes do not contain information about cell types, using all gene expression data would enter noise into our results.  Reducing the dataset to only take into account a reduced dataset with lower dimensionality would decrease noise and strengthen the signal.
To do this, we will perform principal component analysis using the RunPCA() function
on the variable features we have identified above.

```{r}
pbmc_filtered <- RunPCA(pbmc_filtered, features = VariableFeatures(object = pbmc_filtered))
```

We can list the genes whose expressions dominate the principal components.

```{r}
print(pbmc_filtered[["pca"]], dims = 1:5, nfeatures = 5)
```

We can also visualise the contributions of these genes' expressions to the principle components, using the VizDimLoadings() command.

```{r}
VizDimLoadings(pbmc_filtered, dims = 1:2, reduction = "pca")
```

We can also plot the scatterplot of cells in the plane of the first two principal components.

```{r}
DimPlot(pbmc_filtered, reduction = "pca")
```

Alternatively, we can use the DimHeatMap() function to explore qualitatively
which principal components can reveal heterogeneity in the dataset.
Let us look at the expression patterns in cells for the first 15 datasets.
Look at the help of the DimHeatmap() function to interpret its arguments.

```{r}
DimHeatmap(pbmc_filtered, dims = 1:15, cells = 500, balanced = TRUE)
```


To determine the dimensionality in a quantitative way, we can plot the eigenvalues of the principal component analysis, using the ElbowPlot() function.  The idea is that when the curve is almost flat, little new information is added by including the principal component in the further analysis.


```{r}
ElbowPlot(pbmc_filtered)
```


It is always better to include more principal components rather than too few.
Including more would result in an increase in computational time, while missing principal components would result in the loss valuable data.
As we can still just about see some patterns in the DimHeatmap() plots, we will include 15 principal components in the further analysis.

## Optional task

Alternatively, we can plot a jackstraw plot using the JackStraw function.
Feel free to explore that function.  For details, see the Seurat tutorial.


## Running non-linear dimensional reduction using UMAP

Next, let us run a non-linear dimension reduction algorithm, UMAP, which preserves local and global structure in the data.  This algorithm, unlike PCA can visualise the cells in 2 dimensions.  We will use the RunUMAP() function, specifying the first 15 principal components as input.

```{r}
pbmc_filtered <- RunUMAP(pbmc_filtered, dims = 1:15)
```

We can plot the cells using the UMAP coordinates.

```{r}
DimPlot(pbmc_filtered, reduction = "umap")
```


# 3. Clustering

Next, we will identify clusters in the dimensionality reduced data.
Seurat uses a XX technique to do this, using the XX() function.  First, we identify the k nearest neighbours of each cell using the FindNeighbors() function.  Then, we iteratively connect them together, to get the clusters, using the FindClusters() function.

```{r}
pbmc_filtered_PCA_15 <- FindNeighbors(pbmc_filtered, dims = 1:15)
pbmc_filtered_PCA_15 <- FindClusters(pbmc_filtered_PCA_15, resolution = 0.5)
```

Cluster IDs can be extracted from the SeuratObject using the Idents() function.

```{r}
head(Idents(pbmc_filtered_PCA_15), 5)
```

Let us also plot the UMAP reduced data, marking the cluster IDs.

```{r}
DimPlot(pbmc_filtered_PCA_15, reduction = "umap")
```


# 4. Save the filtered data.

Finally, save the filtered SeuratObject for further analysis.

```{r}
saveRDS(pbmc_filtered_PCA_15, file = "pbmc3k_clustered_PCA_15.rds")
```


# 5. Analysis of robustness

In general, it is good practice to repeat the analysis when including a different number of principal components, to check if the downstream analysis results are consistent.

```{r}
pbmc_filtered_PCA_5 <- FindNeighbors(pbmc_filtered, dims = 1:5)
pbmc_filtered_PCA_5 <- FindClusters(pbmc_filtered_PCA_5, resolution = 0.5)
pbmc_filtered_PCA_50 <- FindNeighbors(pbmc_filtered, dims = 1:50)
pbmc_filtered_PCA_50 <- FindClusters(pbmc_filtered_PCA_50, resolution = 0.5)
```

```{r}
DimPlot(pbmc_filtered_PCA_5, reduction = "umap")
```

```{r}
DimPlot(pbmc_filtered_PCA_50, reduction = "umap")
```

```{r}
saveRDS(pbmc_filtered_PCA_5, file = "pbmc3k_clustered_PCA_5.rds")
saveRDS(pbmc_filtered_PCA_50, file = "pbmc3k_clustered_PCA_50.rds")
```
